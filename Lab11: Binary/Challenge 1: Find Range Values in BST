class TreeNode:
    def __init__(self, val):
        self.val = val            # Guardamos el valor del nodo
        self.left = None          # Inicializamos el hijo izquierdo como None
        self.right = None         # Inicializamos el hijo derecho como None

def build_bst(values):
    if not values:               # Si la lista est치 vac칤a, no hay 치rbol que construir
        return None              # Retornamos None

    root = TreeNode(values[0])   # Creamos la ra칤z del 치rbol con el primer valor de la lista
    for val in values[1:]:       # Recorremos el resto de valores
        insert(root, val)        # Insertamos cada valor en el 치rbol usando la funci칩n insert
    return root                  # Devolvemos la ra칤z del 치rbol construido

def insert(root, val):
    if val < root.val:           # Si el valor a insertar es menor al valor actual del nodo
        if root.left is None:    # Si no hay hijo izquierdo
            root.left = TreeNode(val)  # Creamos un nuevo nodo a la izquierda
        else:
            insert(root.left, val)     # Si ya hay hijo izquierdo, seguimos insertando recursivamente
    else:                        # Si el valor es mayor o igual al nodo actual
        if root.right is None:   # Si no hay hijo derecho
            root.right = TreeNode(val) # Creamos un nuevo nodo a la derecha
        else:
            insert(root.right, val)    # Si ya hay hijo derecho, seguimos insertando recursivamente

def range_query(root, min_val, max_val):
    result = []                  # Lista para guardar los valores que est치n en el rango

    def inorder(node):
        if not node:             # Si el nodo es None, terminamos esta rama
            return
        if node.val > min_val:   # Si el valor del nodo es mayor al m칤nimo del rango
            inorder(node.left)   # Revisamos el sub치rbol izquierdo
        if min_val <= node.val <= max_val:  # Si el valor est치 dentro del rango
            result.append(node.val)         # Lo agregamos al resultado
        if node.val < max_val:   # Si el valor del nodo es menor al m치ximo del rango
            inorder(node.right)  # Revisamos el sub치rbol derecho

    inorder(root)                # Iniciamos el recorrido desde la ra칤z
    return result                # Devolvemos la lista de valores en el rango


# Test 1: Normal range
print(range_query(build_bst([7, 3, 11, 1, 5, 9, 13]), 5, 10) == [5, 7, 9])  # 游꿢

# Test 2: Full range
print(range_query(build_bst([6, 4, 8, 2]), 1, 10) == [2, 4, 6, 8])  # 游늵

# Test 3: No values in range
print(range_query(build_bst([20, 10, 30]), 1, 5) == [])  # 游닔

# Test 4: Single value
print(range_query(build_bst([15]), 10, 20) == [15])  # 游꺔

# Test 5: Edge values
print(range_query(build_bst([15, 10, 20, 5, 25]), 10, 20) == [10, 15, 20])  # 游댕
